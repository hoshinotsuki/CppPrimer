# 数据成员对齐规则
其实字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则:
1. struct内每个成员相对struct首地址的offset，都是该成员大小的整数倍。
2. struct变量的首地址是内部最大成员的倍数;
3. sizeof(struct)为struct最宽基本类型成员大小的整数倍。

## 准则 1
结构(struct)或联合(union)的数据成员，第一个数据成员放在offset为0的地方，每个数据成员存储的起始位置要从该成员(每个成员本身)大小的整数倍开始(比如int在32位机为４字节,则要从４的整数倍地址开始存储)。
```cpp
struct node
{
     char a;//1
     int b//4
};
sizeof(node)=8
```
a存放在0offset的位置。b的存储起始位置为1，为了满足对齐原则，int大小为4，b的存储位置应该为4的整数倍，所以要在a后补齐，所以b的存储起始位置为4。所以node大小为8。 

## 准则2 结构体作为成员
如果一个结构里有某些结构体成员,则结构体成员要从```其内部最大元素大小的整数倍```地址开始存储.(struct a里存有struct b,b里有char,int ,double等元素,那b应该从8的整数倍开始存储.)
```cpp
struct pa
{
   char a;//1
   node b;//b内部最大元素大小是4，所以b的起始位置要是4的整倍数.在a后面补位。
}
sizeof(pa)=12//4+8=12.
``` 
# 准则3 sizeof(struct)
结构体的总大小,也就是sizeof的结果,.必须是其内部最大成员的整数倍（结构体成员以最大成员为代表）.不足的要补齐.
```cpp
struct node
{
    double a;//8
    char b;//1
}
sizeof(node)=16//9->2*8=16
```
按1,2原则可计算出结果应为9;
但结构体大小应为```最大成员的整倍数```，因此结果应为16
如果编译器中提供了```#pragma pack(n)```，上述对其模式就不适用了，例如设定变量以n字节对齐方式，则上述成员类型对齐宽度（应当也包括收尾对齐）应该选择```成员类型宽度和n中较小者```；
 