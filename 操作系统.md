# 操作系统

Q1.
```CPP
64位系统和32位系统的区别
```
A1.
```CPP
8位的cpu，一次处理一个8位的数据，比如'10001000'，如果'+1'这个运算，cpu要先做'+'，再做'1'传给cpu
16位的cpu，一次处理2个字节(16位)
32位的cpu，一次处理4个字节 
```

| type           | 32bit - byte count | 64bit - byte count | range                             |
| :------------- | ------------------ | ------------------ | --------------------------------- |
| bool           | 1                  |                    | ture,false                        |
| char           | 1                  |                    | -128~127(-2^7~2^7-1)              |
| unsigned char  | 1                  |                    | 0~255(0~2^8-1)                    |
| short          | 2                  |                    | -32768~32767(-2^15~2^15-1)        |
| unsigned short | 2                  |                    | 0~65535(2^16-1)                   |
| int            | 4                  |                    | (-2^31~2^31-1)                    |
| unsigned int   | 4                  |                    | (0~2^32-1)                        |
| long           | 4                  | 8                  |                                   |
| unsigned long  | 4                  | 8                  |                                   |
| long long      | 8                  |                    | -2^64~2^64-1                      |
| float          | 4                  |                    | -2^128~2^128，精度为6~7位有效数字 |
| double         | 8                  |                    | -2^1024~2^1024，精度为15~16位     |
| long double    | 8                  |                    | -2^1024~2^1024，精度为15~16位     |
| *              | 4                  | 8                  |                                   |
|                |                    |                    |                                   |

除了long和指针有区别之外，其它不变。



## 进程线程
Q:
```CPP
下面哪些方式可以用于线程之间的同步？ 
临界区。√
互斥区。√
事件。√
信号量。√
```
A:
```CPP
进程中线程同步的四种常用方式：
- 临界区（CCriticalSection）
　　当多个线程访问一个独占性共享资源时，可以使用临界区对象。[拥有临界区的线程]可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止。具体应用方式：
　　1. 定义临界区对象CcriticalSection g_CriticalSection;
　　2. 在访问共享资源（代码或变量）之前，先获得临界区对象，g_CriticalSection.Lock（）；
　　3. 访问共享资源后，则放弃临界区对象，g_CriticalSection.Unlock（）；
　　
- 事件（CEvent）
　　事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。比如在某些网络应用程序中，一个线程如A负责侦听通信端口，另外一个线程B负责更新用户数据，利用事件机制，则线程A可以通知线程B何时更新用户数据。
　　每个Cevent对象可以有两种状态：有信号状态和无信号状态。
　　Cevent类对象有两种类型：人工事件和自动事件。
　　自动事件对象，在被至少一个线程释放后自动返回到无信号状态；
　　人工事件对象，获得信号后，释放可利用线程，但直到调用成员函数ReSet()才将其设置为无信号状态。
　　在创建Cevent对象时，默认创建的是自动事件。
　　1. 1234CEvent(
      BOOL bInitiallyOwn=FALSE,
      //指定事件对象初始化状态，TRUE为有信号，FALSE为无信号；
      BOOL bManualReset=FALSE,
      //指定要创建的事件是属于人工事件还是自动事件。TRUE为人工事件，FALSE为自动事件；
      LPCTSTR lpszName=NULL,          
      LPSECURITY_ATTRIBUTES lpsaAttribute=NULL);  
　　2. BOOL CEvent：：SetEvent();
　　将Cevent类对象的状态设置为有信号状态。
　　如果事件是人工事件，则Cevent类对象保持为有信号状态，直到调用成员函数ResetEvent()将其重新设为无信号状态时为止。
　　如果为自动事件，则在SetEvent（）后将事件设置为有信号状态，由系统自动重置为无信号状态。　　
　　3. BOOL CEvent：：ResetEvent();
　　将事件的状态设置为无信号状态，并保持该状态直至SetEvent（）被调用为止。
　　由于自动事件是由系统自动重置，故自动事件不需要调用该函数。
　　4. 一般通过调用WaitForSingleObject（）函数来监视事件状态。
　　
- 互斥量（CMutex）
　　互斥对象和临界区对象非常相似，只是其[允许在进程间]使用，而临界区[只限制与同一进程的各个线程]之间使用，但是更节省资源，更有效率。
　　
- 信号量（CSemphore）
　　当需要一个计数器来[限制可以使用某共享资源的线程数目]时，可以使用“信号量”对象。
　　CSemaphore类对象保存了对当前访问某一个指定资源的线程的计数值，该计数值是[当前还可以使用该资源的线程数目]。
　　如果这个计数达到了零，则所有对这个CSemaphore类对象所控制的资源的访问尝试都被放入到一个队列中等待，直到超时或计数值不为零为止。
　　CSemaphore(
　　LONG lInitialCount = 1,
      //信号量对象的初始计数值，即可访问线程数目的初始值；
　　LONG lMaxCount = 1,
      //信号量对象计数值的最大值，该参数决定了同一时刻可访问由信号量保护的资源的线程最大数目；
　　LPCTSTR pstrName = NULL,
　　LPSECURITY_ATTRIBUTES lpsaAttributes = NULL
　　); 
　　一般是将当前可用资源计数设置为最大资源计数，每增加一个线程对共享资源的访问，当前可用资源计数就减1，只要当前可用资源计数大于0，就可以发出信号量信号。如果为0，则放入一个队列中等待。
　　线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore（）函数将当前可用资源数加1。
```


